#!/usr/bin/env tsx
/**
 * Malaysian Law MCP — Ingestion Pipeline
 *
 * Fetches Malaysian legislation from CommonLII (commonlii.org/my/legis/).
 * CommonLII is a comprehensive free legal database maintained by AustLII
 * that provides well-structured English text of Malaysian consolidated statutes.
 *
 * **Census-driven**: Reads data/census.json (generated by scripts/census.ts) to
 * enumerate ALL federal Acts. Falls back to KEY_MALAYSIAN_ACTS if census is missing.
 *
 * Usage:
 *   npm run ingest                    # Full ingestion (from census)
 *   npm run ingest -- --limit 5       # Test with 5 acts
 *   npm run ingest -- --skip-fetch    # Reuse cached HTML
 *   npm run ingest -- --resume        # Skip acts that already have seed files
 *
 * Data source: commonlii.org/my/legis/ (AustLII / CommonLII)
 * Format: HTML (English text of consolidated Malaysian statutes)
 * License: Open Access (government work product)
 */

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';
import { fetchWithRateLimit } from './lib/fetcher.js';
import {
  parseMalaysianHtml,
  KEY_MALAYSIAN_ACTS,
  type ActIndexEntry,
  type ParsedAct,
} from './lib/parser.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const SOURCE_DIR = path.resolve(__dirname, '../data/source');
const SEED_DIR = path.resolve(__dirname, '../data/seed');
const CENSUS_PATH = path.resolve(__dirname, '../data/census.json');

interface CensusAct {
  id: string;
  slug: string;
  title: string;
  titleClean: string;
  actNumber: string;
  year: string;
  url: string;
  classification: 'ingestable' | 'inaccessible' | 'metadata_only';
  repealed: boolean;
  repealedBy: string;
}

interface CensusData {
  generated_at: string;
  stats: {
    total: number;
    class_ingestable: number;
    class_inaccessible: number;
    class_metadata_only: number;
  };
  ingestion?: {
    completed_at: string;
    total_laws: number;
    total_provisions: number;
    coverage_pct: string;
  };
  laws: CensusAct[];
}

function parseArgs(): { limit: number | null; skipFetch: boolean; resume: boolean } {
  const args = process.argv.slice(2);
  let limit: number | null = null;
  let skipFetch = false;
  let resume = false;

  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--limit' && args[i + 1]) {
      limit = parseInt(args[i + 1], 10);
      i++;
    } else if (args[i] === '--skip-fetch') {
      skipFetch = true;
    } else if (args[i] === '--resume') {
      resume = true;
    }
  }

  return { limit, skipFetch, resume };
}

/**
 * Convert a census act entry into the ActIndexEntry format used by the parser.
 */
function censusActToIndexEntry(censusAct: CensusAct): ActIndexEntry {
  // Detect if this act uses "Article" numbering (Federal Constitution)
  const usesArticles = /constitution/i.test(censusAct.title) && !/amendment/i.test(censusAct.title);

  return {
    id: censusAct.id,
    slug: censusAct.slug,
    title: censusAct.title,
    titleClean: censusAct.titleClean,
    actNumber: censusAct.actNumber,
    year: censusAct.year,
    status: censusAct.repealed ? 'repealed' : 'in_force',
    url: censusAct.url,
    usesArticles,
  };
}

/**
 * Load acts from census.json if available, otherwise fall back to KEY_MALAYSIAN_ACTS.
 */
function loadActList(): ActIndexEntry[] {
  if (fs.existsSync(CENSUS_PATH)) {
    const raw = fs.readFileSync(CENSUS_PATH, 'utf-8');
    const census = JSON.parse(raw) as CensusData;

    console.log(`  Census: ${census.stats.total} Acts (generated ${census.generated_at})`);

    // Only include ingestable acts
    const ingestable = census.laws.filter(a => a.classification === 'ingestable');
    console.log(`  Ingestable: ${ingestable.length} Acts`);

    return ingestable.map(censusActToIndexEntry);
  }

  console.log('  WARNING: No census.json found — falling back to KEY_MALAYSIAN_ACTS (5 acts)');
  console.log('  Run: npx tsx scripts/census.ts   to generate full census\n');
  return KEY_MALAYSIAN_ACTS;
}

/**
 * Create a metadata-only seed file when fetching/parsing fails.
 */
function createFallbackSeed(act: ActIndexEntry): ParsedAct {
  return {
    id: act.id,
    type: 'statute',
    title: act.titleClean || act.title,
    title_en: act.titleClean || act.title,
    short_name: act.titleClean || act.title,
    status: act.status,
    issued_date: act.year || '',
    in_force_date: act.year || '',
    url: act.url,
    provisions: [],
    definitions: [],
  };
}

async function fetchAndParseActs(
  acts: ActIndexEntry[],
  skipFetch: boolean,
  resume: boolean,
): Promise<void> {
  console.log(`\nProcessing ${acts.length} Malaysian laws from commonlii.org...\n`);

  fs.mkdirSync(SOURCE_DIR, { recursive: true });
  fs.mkdirSync(SEED_DIR, { recursive: true });

  let processed = 0;
  let resumed = 0;
  let skipped = 0;
  let failed = 0;
  let notFound = 0;
  let totalProvisions = 0;
  let totalDefinitions = 0;
  const startTime = Date.now();

  const report: {
    act: string;
    provisions: number;
    definitions: number;
    status: string;
  }[] = [];

  for (const act of acts) {
    const sourceFile = path.join(SOURCE_DIR, `${act.id}.html`);
    const seedFile = path.join(SEED_DIR, `${act.id}.json`);

    // Resume support: skip acts that already have seed files
    if (resume && fs.existsSync(seedFile)) {
      const existing = JSON.parse(fs.readFileSync(seedFile, 'utf-8')) as ParsedAct;
      totalProvisions += existing.provisions?.length ?? 0;
      totalDefinitions += existing.definitions?.length ?? 0;
      resumed++;
      processed++;
      continue;
    }

    // Skip if seed already exists and we're in skip-fetch mode
    if (skipFetch && fs.existsSync(seedFile)) {
      const existing = JSON.parse(fs.readFileSync(seedFile, 'utf-8')) as ParsedAct;
      const provCount = existing.provisions?.length ?? 0;
      const defCount = existing.definitions?.length ?? 0;
      totalProvisions += provCount;
      totalDefinitions += defCount;
      report.push({
        act: act.titleClean.substring(0, 40),
        provisions: provCount,
        definitions: defCount,
        status: 'cached',
      });
      skipped++;
      processed++;
      continue;
    }

    try {
      let html: string;

      if (fs.existsSync(sourceFile) && skipFetch) {
        html = fs.readFileSync(sourceFile, 'utf-8');
      } else {
        process.stdout.write(`  [${processed + 1}/${acts.length}] Fetching ${act.id}...`);

        try {
          const result = await fetchWithRateLimit(act.url);

          if (result.status === 404 || result.body.includes('404 File not found')) {
            console.log(` 404 -- SKIPPED`);
            const fallback = createFallbackSeed(act);
            fs.writeFileSync(seedFile, JSON.stringify(fallback, null, 2));
            report.push({
              act: act.titleClean.substring(0, 40),
              provisions: 0,
              definitions: 0,
              status: '404 (metadata only)',
            });
            notFound++;
            processed++;
            continue;
          }

          if (result.status !== 200) {
            console.log(` HTTP ${result.status}`);
            const fallback = createFallbackSeed(act);
            fs.writeFileSync(seedFile, JSON.stringify(fallback, null, 2));
            report.push({
              act: act.titleClean.substring(0, 40),
              provisions: 0,
              definitions: 0,
              status: `HTTP ${result.status} (fallback)`,
            });
            failed++;
            processed++;
            continue;
          }

          html = result.body;
          fs.writeFileSync(sourceFile, html);
          console.log(` OK (${(html.length / 1024).toFixed(0)} KB)`);
        } catch (fetchError) {
          const msg =
            fetchError instanceof Error
              ? fetchError.message
              : String(fetchError);
          console.log(` FETCH FAILED: ${msg}`);
          const fallback = createFallbackSeed(act);
          fs.writeFileSync(seedFile, JSON.stringify(fallback, null, 2));
          report.push({
            act: act.titleClean.substring(0, 40),
            provisions: 0,
            definitions: 0,
            status: `FETCH FAILED`,
          });
          failed++;
          processed++;
          continue;
        }
      }

      const parsed = parseMalaysianHtml(html, act);
      fs.writeFileSync(seedFile, JSON.stringify(parsed, null, 2));
      totalProvisions += parsed.provisions.length;
      totalDefinitions += parsed.definitions.length;
      console.log(
        `    -> ${parsed.provisions.length} provisions, ${parsed.definitions.length} definitions`,
      );
      report.push({
        act: act.titleClean.substring(0, 40),
        provisions: parsed.provisions.length,
        definitions: parsed.definitions.length,
        status: 'OK',
      });
    } catch (error) {
      const msg = error instanceof Error ? error.message : String(error);
      console.log(`  ERROR parsing ${act.titleClean}: ${msg}`);
      const fallback = createFallbackSeed(act);
      fs.writeFileSync(seedFile, JSON.stringify(fallback, null, 2));
      report.push({
        act: act.titleClean.substring(0, 40),
        provisions: 0,
        definitions: 0,
        status: `ERROR: ${msg.substring(0, 50)}`,
      });
      failed++;
    }

    processed++;

    // Progress log every 50 acts
    if (processed % 50 === 0) {
      const elapsed = ((Date.now() - startTime) / 1000).toFixed(0);
      const eta = ((Date.now() - startTime) / processed * (acts.length - processed) / 1000).toFixed(0);
      console.log(`\n  --- Progress: ${processed}/${acts.length} (${elapsed}s elapsed, ~${eta}s remaining) ---\n`);
    }
  }

  const totalElapsed = ((Date.now() - startTime) / 1000).toFixed(1);

  console.log(`\n${'='.repeat(70)}`);
  console.log('INGESTION REPORT');
  console.log('='.repeat(70));
  console.log(`\n  Source:      commonlii.org/my/legis/ (AustLII / CommonLII)`);
  console.log(`  License:     Open Access (government work product)`);
  console.log(`  Elapsed:     ${totalElapsed}s`);
  console.log(`  Processed:   ${processed}`);
  console.log(`  Resumed:     ${resumed}`);
  console.log(`  Cached:      ${skipped}`);
  console.log(`  Failed:      ${failed}`);
  console.log(`  Not found:   ${notFound}`);
  console.log(`  Total provisions:  ${totalProvisions}`);
  console.log(`  Total definitions: ${totalDefinitions}`);

  if (report.length <= 100) {
    console.log(`\n  ${'Act'.padEnd(42)} ${'Prov'.padEnd(8)} ${'Defs'.padEnd(8)} Status`);
    console.log(`  ${'-'.repeat(42)} ${'-'.repeat(8)} ${'-'.repeat(8)} ${'-'.repeat(20)}`);
    for (const r of report) {
      console.log(
        `  ${r.act.padEnd(42)} ${String(r.provisions).padEnd(8)} ${String(r.definitions).padEnd(8)} ${r.status}`,
      );
    }
  } else {
    const okCount = report.filter(r => r.status === 'OK').length;
    const failedCount = report.filter(r => !['OK', 'cached'].includes(r.status)).length;
    const cachedCount = report.filter(r => r.status === 'cached').length;
    console.log(`\n  New ingestions:  ${okCount}`);
    console.log(`  Cached:          ${cachedCount}`);
    console.log(`  Failed:          ${failedCount}`);
    if (failedCount > 0) {
      console.log('\n  Failed/not-found acts:');
      for (const r of report.filter(r => !['OK', 'cached'].includes(r.status))) {
        console.log(`    ${r.act.padEnd(42)} ${r.status}`);
      }
    }
  }

  // Update census.json with ingestion stats
  if (fs.existsSync(CENSUS_PATH)) {
    const census = JSON.parse(fs.readFileSync(CENSUS_PATH, 'utf-8')) as CensusData;
    census.ingestion = {
      completed_at: new Date().toISOString(),
      total_laws: processed - failed - notFound,
      total_provisions: totalProvisions,
      coverage_pct: ((processed - failed - notFound) / acts.length * 100).toFixed(1),
    };

    // Update classification for 404 acts
    if (notFound > 0) {
      const notFoundReport = report.filter(r => r.status.includes('404'));
      for (const fr of notFoundReport) {
        const censusAct = census.laws.find((a: CensusAct) => a.titleClean.startsWith(fr.act.substring(0, 30)));
        if (censusAct) {
          censusAct.classification = 'inaccessible';
        }
      }
      census.stats.class_ingestable = census.laws.filter((a: CensusAct) => a.classification === 'ingestable').length;
      census.stats.class_inaccessible = census.laws.filter((a: CensusAct) => a.classification === 'inaccessible').length;
    }

    fs.writeFileSync(CENSUS_PATH, JSON.stringify(census, null, 2) + '\n');
    console.log(`\n  Updated census.json with ingestion stats.`);
  }
}

async function main(): Promise<void> {
  const { limit, skipFetch, resume } = parseArgs();

  console.log('Malaysian Law MCP -- Ingestion Pipeline');
  console.log('=======================================\n');
  console.log(`  Source: CommonLII (commonlii.org/my/legis/)`);
  console.log(`  Maintainer: AustLII / CommonLII`);
  console.log(`  Format: HTML (English text of consolidated statutes)`);
  console.log(`  Rate limit: 500ms between requests`);

  if (limit) console.log(`  --limit ${limit}`);
  if (skipFetch) console.log(`  --skip-fetch`);
  if (resume) console.log(`  --resume (skip existing seed files)`);

  const allActs = loadActList();
  const acts = limit ? allActs.slice(0, limit) : allActs;
  await fetchAndParseActs(acts, skipFetch, resume);
}

main().catch(error => {
  console.error('Fatal error:', error);
  process.exit(1);
});
